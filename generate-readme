#!/usr/bin/env node

var request = require('request'),
    genEndpoints = require('./endpoints/endpoints'),
    render = require('./endpoints/render'),
    packageJson = require('./package.json'),
    p = console.log,
    endPoints = {get: [], post: [], put: [], delete: []},
    data;

genEndpoints.forEach(item => {
    endPoints[item.type].push({
        path: item.path,
        fields: item.fields,
        description: item.description
    });
});

data = render(endPoints);

function tooLong(str) {
    var len = 76,
        pad = '              ',
        idx = len;

    if (str.length > 76) {
        for (; idx > 0; idx--) {
            // if there is a space, break the string
            if (str.charCodeAt(idx) === 32) break;
        }

        // Create a string broken at the space,
        // put back together with line break,
        // make sure to pad the second line.
        str = [
            str.substring(0, idx),
            pad + str.substring(idx)
        ].join('\n');
    }

    return str;
}

function genDesc(o, sub, type) {
  var headers = sub ? o : o.headers;
  var fields = sub ? o : o.fields;

  if (!sub) {
    var desc = o.description
        .replace(/[^\/](:\w+)/g, (match, p1) => ' `'+ p1 +'`')
        .replace(/(\/[A-Za-z:/]+)/g, (match, p1) => '`' + p1 + '`')

    p('### %s `%s`\n', type, o.path);
    p('> %s\n', desc);

    if (headers.length > 0) {
        p('#### Headers\n');

        p('```');
        headers.forEach(f => {
            p(f.field);
            p('- type:        %s', f.type);
            p('- required:    %s', f.required);
            p('- description: %s', tooLong(f.description));
            p('- requirement: %s', tooLong(f.requirement));
            p('');
        });
        p('```');
        p('');
    }

    if (fields.length > 0) {
      p('#### Fields\n');

      p('```');
      fields.forEach(function (f) {
        if (typeof f.subObject !== 'undefined') {
          p(f.field);
          p('- type:     subObject');
          p('- required: false');
          p('- fields:');

          genDesc(f.subObject, true);
        } else {
          p(f.field);
          p('- type:        %s', f.type);
          p('- required:    %s', f.required);
          p('- description: %s', tooLong(f.description));
          p('- requirement: %s', tooLong(f.requirement));
          p('');
        }
      });
      p('```');
      p('');
      p('');
    }
  }
}

p('# ShipIt API\n');
p('[![CircleCI](https://circleci.com/gh/turnerlabs/shipit-api/tree/master.svg?style=shield)](https://circleci.com/gh/turnerlabs/shipit-api/tree/master)\n')
p('API Version `%s`\n', packageJson.version);
p('[Additional documentation](http://blog.harbor.inturner.io/docs/shipit/)\n\n');

Object.keys(data).forEach(type => {
    data[type].forEach(o => {
        genDesc(o, false, type.toUpperCase())
    })
})

p('\nReadme generated by running `./generate-readme > README.md` in repository');

process.exit();
